<%
import Util;

def escape(text) 
{
    if (text.contains('=')) {
        text = text.replaceAll('=', '\\\\=');
    }
    if (text.contains('|')) {
        text = text.replaceAll('\\|', '{vbar}');
    }
    return text;
}

def tagText(tag)
{
    def text = escape(tag);
    if (text.contains('`')) {
        text = text.replaceAll('`', '{backtick}');
    }
    return text;
}

def commentText(tag,tagset)
{
    def text = tagset.mapping.layout.getCanonicalComment(tag, true);
    if (text) {
        // We don't use multi-line descriptions for tags. If there is a multiline comment, then
        // Most likely only the last line is the tag description and previous lines mention
        // tags that have not been mapped yet.
        def lines = text.split('\n');
        if (lines.size() > 0) {
            text = lines[-1];
        }
    
        if (text.startsWith('#')) {
            text = text.length() > 1 ? text[1..-1].trim() : '';
        }
        
        if (text == tag) {
            text = '';
        }
        else if (text.startsWith(tag)) {
            text = text[tag.length()..-1].trim();
            if (text.startsWith('-')) {
                text = text[1..-1].trim();
            }
        }
        
        text = escape(text);
    }

    return text ?: '__No description__';
}

def headerCommentText(tagset)
{
    def text = tagset.mapping.layout.getCanonicalHeaderComment(true) ?: '';

    def lines = text.split('\n');
    for (int i = 0; i < lines.size(); i++) {
        def line = lines[i].trim();;    
        
        if (line.startsWith('#')) {
            line = line.length() > 1 ? line[1..-1].trim() : '';
        }
        
        line = escape(line);
        
        lines[i] = line;
    }
    
    text = lines.join('\n');

    return text ?: '__No description__';
}

def typeText(tag,tagset)
{
    def t = tagset.mapping.getString(tag);
    if (!t.contains('.')) {
        t = tagset.mapping.getString('__META_TYPE_BASE__') + t;
    }
    return Util.typeLink(t);
}

def defaultTypeText(tagset)
{
    def defaultType = tagset.mapping.getString('*');
    if (defaultType && !defaultType.contains('.')) {
        defaultType = tagset.mapping.getString('__META_TYPE_BASE__') + defaultType;
    }
    return defaultType ? Util.typeLink(defaultType) : 'None';
}
%>

<% tagsets.groupBy { it.value.tool }.each{ tool, toolTagsets -> %>

=== ${tool}

<% toolTagsets
    .sort { a,b ->
        (a.value.name as String) <=> (b.value.name as String) ?:
        (a.value.lang as String) <=> (b.value.lang as String) }
    .each { id, tagset -> %>
[[tagset-${ id }]]
==== ${tagset.name} (${tagset.lang})

${Util.editOnGithub(tagset.url)}
*_Layer:_* __${tool}__ +
*_Language:_* __${tagset.lang}__ + 
*_Type base:_* __${tagset.mapping.getString('__META_TYPE_BASE__') ?: 'None'}__ +
*_Default type:_* __${defaultTypeText(tagset)}__

// DESCRIPTION
${headerCommentText(tagset)}

// TABLE OF TAGS IN THE TAGSET
.Tag mappings in ${tagset.name} (${tagset.lang})
[options="header",cols="1,1,3"]
|====
|Tag|Type|Description
<% tagset.mapping.keys.sort()
    .findAll { !it.equals('__META_TYPE_BASE__') && !it.equals('*') }
    .each { tag -> %>
| `${tagText(tag)}`
| ${typeText(tag,tagset)}
| ${commentText(tag,tagset) ?: '__No description__'}
<% } // mapping { %>
|====

// LIST OF MODELS THAT USE THIS TAGSET
<% 
def linkedModels = models
    .findAll { model ->
        model.metadata.entry.any { entry -> 
            entry.@key == "${tool}.tagset" &&
            entry.@value == tagset.name
        }
    };
if (!linkedModels.isEmpty()) { %>
.Models using ${tagset.name} (${tagset.lang})
<% linkedModels.each { model -> %>
* ${Util.modelLink(model)}
<% } %>
<% } else { %>
__This mapping is not used in any models.__
<% } %>

<% } // toolTagsets %>

<% } // tagsets %>
